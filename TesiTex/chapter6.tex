% !TEX root = Tesi.tex
\chead{}

\chapter{From models to code, a case study.}

This chapter covers a case study in which we apply the concepts and ideas previously discussed. For doing so, we describe the Magento platform in which he Madison Island eCommerce website would run. We alse suggest a possible automation for code generation that is compatible with the platform ecosystem and architecture.

\section{Magento overview}

Magento is one of the most powerful and feature-rich online eCommerce platforms currently available. Launched on March 2008, the platform ensures dealers a full flexibility and control over the look, content, and functionality of their online store. Thanks to its intuitive administration interface for content management as well as its robust marketing and merchandising tools, Magento makes it possible to create sites that fully fit unique business needs, putting no constraints on business processes and flows.

From a technical perspective, the platform incorporates the core architectural principles of an object-oriented, PHP-based application that can be easily used to customise and expand an already broad and innovative set of features. In fact, central to the Magento model of software development is the strategy of replacing and extending core code, rather than editing it to support maintainability and flexibility. 

To achieve that goal, Magento software architecture has been built around the concept of self-contained modules holding discrete code organized by feature, thereby reducing each moduleâ€™s external dependencies.

The Magento frontend is designed to optimize storefront customization, with highly extensible themes being the central customization mechanism so that the look and feel of online stores can be easily extended and transformed.

\vspace{0.5cm}
\begin{figure}[H]
  \centering
    \includegraphics[height=12cm]{images/magento/magento-architecture.jpg}
  \caption{Magento Architecture Overview}
  \label{fig:magento-architecture-overview}
\end{figure}
\vspace{0.5cm}

Interacting with the product and its appearance on a Magento web interface means interacting with a presentation layer code that is composed both by view elements (layouts, blocks, and templates) as well as by controllers, which process commands to and from the user interface. 

We can extensively customise the user interface by extending Magento themes capabilities. Since the Magento theme is responsible for organizing both the visual aspect of the interface and the product behavior, modifying its presentational layer opens up a whole new world for content personalisation and enhancement. Each Magento theme resides in a specific directory and includes custom page layouts, templates, skins, and language files that work together to create a distinct user experience.

In our case study, the Madison Island frontend is built around a Magento theme that has been specifically customised, granting a unique and tailored user experience to our website. 

\subsection{Layout Updates XML}

Magento offers great flexibility and re-usability of design by layouts defined in XML files. In fact, each Magento module may define its own layout XML file and participate in the process of building the page output. This result is accomplished through a set of instructions contained in these XML files, and grouped in \textit{layout handle}s. These directions play a fundamental role in determining the final look and feel of the page displayed to the user.

For example, the handle \textit{catalog\_product\_view} is used to add content to the product detail page, and \textit{checkout\_cart\_index} to the shopping cart page. The following is an excerpt of the \textit{catalog\_category\_default} and \textit{catalog\_product\_gallery} layout handle instructions that are contained in the layout XML file and linked to the module used by Magento for all the catalogue-related functionalities (Mage\_Catalog):

\vspace{0.5cm}
\lstset{language=XML}
\begin{lstlisting} 

  <catalog_category_default translate="label">
  <label>Catalog Category (Non-Anchor)</label>
  <reference name="left">
      <block type="catalog/navigation" name="catalog.leftnav" after="currency" template="catalog/navigation/left.phtml"/>
  </reference>
  <reference name="content">
      <block type="catalog/category_view" name="category.products" template="catalog/category/view.phtml">
          <block type="catalog/product_list" name="product_list" template="catalog/product/list.phtml">
              <block type="catalog/product_list_toolbar" name="product_list_toolbar" template="catalog/product/list/toolbar.phtml">
                  <block type="page/html_pager" name="product_list_toolbar_pager"/>
                  <!-- The following code shows how to set your own pager increments -->
                  <!--
                      <action method="setDefaultListPerPage"><limit>4</limit></action>
                      <action method="setDefaultGridPerPage"><limit>9</limit></action>
                      <action method="addPagerLimit"><mode>list</mode><limit>2</limit></action>
                      <action method="addPagerLimit"><mode>list</mode><limit>4</limit></action>
                      <action method="addPagerLimit"><mode>list</mode><limit>6</limit></action>
                      <action method="addPagerLimit"><mode>list</mode><limit>8</limit></action>
                      <action method="addPagerLimit" translate="label"><mode>list</mode><limit>all</limit><label>All</label></action>
                  -->
              </block>
              <action method="addColumnCountLayoutDepend"><layout>empty</layout><count>6</count></action>
              <action method="addColumnCountLayoutDepend"><layout>one_column</layout><count>5</count></action>
              <action method="addColumnCountLayoutDepend"><layout>two_columns_left</layout><count>4</count></action>
              <action method="addColumnCountLayoutDepend"><layout>two_columns_right</layout><count>4</count></action>
              <action method="addColumnCountLayoutDepend"><layout>three_columns</layout><count>3</count></action>
              <action method="setToolbarBlockName"><name>product_list_toolbar</name></action>
          </block>
      </block>
  </reference>
</catalog_category_default>

...

<catalog_product_gallery translate="label">
        <label>Catalog Product Image Gallery Popup</label>
        <!-- Mage_Catalog -->
        <reference name="root">
            <action method="setTemplate"><template>page/popup.phtml</template></action>
        </reference>
        <reference name="content">
            <block type="catalog/product_gallery" name="catalog_product_gallery" template="catalog/product/gallery.phtml"/>
        </reference>
    </catalog_product_gallery>


\end{lstlisting}
\vspace{0.5cm}

As shown above, child nodes are created inside these \textit{layout handle}s to determine which content should appear on any distinct page where these layout handles gets added to an XML structure called \textit{page tree}.

These child nodes are called \textit{block}s, which may, in turn, contain child \textit{block}s of their own. 
Magento blocks can be structural or content blocks, depending on whether or not they have a template associated with them.
Usually, structural blocks, as shown in Figure \ref{fig:magento-term-blocks}, define the primary structure of the page. These blocks do not explicitly render anything to the screen, and mostly act as wrappers for their children blocks.
Finally, each non-structural \textit{block} would contain a template associated to it, which would be responsible for displaying some specific content.

\vspace{0.5cm}
\begin{figure}[H]
  \centering
  \subfloat[Structural Blocks]{{\includegraphics[width=11cm]{images/magento/term-blocks-structural.png} }}%
  \qquad
  \subfloat[Content Blocks]{{\includegraphics[width=11cm]{images/magento/term-blocks-content.png} }}%
  \caption{Magento Blocks Page Structure}%
  \label{fig:magento-term-blocks}%
\end{figure}


In summary, each page of the website can be thought as a composition of Magento \textit{block}s representing a specific page tree configuration. As shown in \ref{fig:magento-madison-island-theme}, for the Madison Island theme example, each one of these blocks holds its associated rendering template that gets assembled and internally rendered before being returned to the user browser in the HTTP response.

\vspace{0.5cm}
\begin{figure}[H]
  \centering
    \includegraphics[width=14cm]{images/magento/madison-island-theme.png}
  \caption{Madison Island templates composition}
  \label{fig:magento-madison-island-theme}
\end{figure}
\vspace{0.5cm}

The versatility offered by the Magento rendering engine through the layout update XML mechanism allows us to dynamically append block children under certain conditions or pass parameters to the existing blocks that would affect their rendering behavior. This behavior is beneficial to map the changes we identified through the personalization process integrated within the updated \textit{IFMLModel} describing the enhanced interface offered to the customers on the platform.

In fact, we are in a position now to generate and forward customized XML updates to Magento to reflect those requested changes and efficiently see them implemented on the website.

\newpage
\section{An approach for code generation}

The main idea behind the code generation method is to use the updated \textit{IFMLModel} processed in the previous stage and use it as the input document of an additional transformation capable of generating code understandable by the target platform, in this case, Magento. This generated code would have the form of the Layout Update XML instructions described in the previous section. Finally, these automatically generated XML update snippets will be interpreted and treated from the Magento rendering engine as any other layout update XML file when the profiled user is logged in on the website.

\vspace{0.5cm}
\begin{figure}[H]
  \centering
    \includegraphics[width=14cm]{images/code-generation.png}
  \caption{Code generation overview}
  \label{fig:code-generation}
\end{figure}
\vspace{0.5cm}

\subsection{XML Metadata Interchange overview}

XMI (XML Metadata Interchange) is a proposed use of the Extensible Markup Language (XML) that is intended to provide a standard way for programmers and other users to exchange information about metadata (essentially, information about what a set of data consists of and how it is organized)\cite{xmi}. 

Both the \textit{RealDataUsage} and \textit{IFML} models and metamodels definition presented in the previous chapters have been using and persisted throught the XMI specification.

\vspace{0.5cm}
\begin{figure}[H]
  \centering
    \includegraphics[width=15cm]{images/xmi-header.png}
  \caption{XMI definition for the updated IFMLModel}
  \label{fig:xmi-header}
\end{figure}
\vspace{0.5cm}


Since XMI is XML-based, we decided to employ XSLT to transformat the XMI representation of the enhanced \textit{IFMLModel} for code generation of the target documents. 

\subsection{Applying XSL Transformations}

XSL Transformations (XSLT 1.0) is a language for transforming XML documents into other XML documents, text documents or HTML documents\cite{xslt} whose detailed language specifications are beyond the scope of this work.

Still, in our journey towards code generation, we considered XSLT a suitable tool because we are effectively looking for a valid XMI-XML transformation. Specifically, our proposed approach limits itself to this XML documents conversion only, leaving the Magento rendering engine to implement the rest of the operations as usual. In fact, Magento would still be the authority for building up the final HTML response after merging all the layout updates collected and recursively rendering all the associated block templates.

The goal described above is achievable thanks to XSLT functionalities for adding nodes and attributes to or from the target file, rearranging and sorting elements and making decisions about which items to hide and display.In fact, XSLT is capable of efficiently transforming an XML source-tree (our \textit{IFMLModel} XMI in our case) into an XML result-tree (Magento layout update XML in our case).

Because XSLT uses \textit{XPath} to define parts of the source document that should match some predefined templates to be converted into some others (\ref{xslt-processing}), our objective is to identify those templates from the source XMI document and propose a possible transformation definition resulting in a valid layout update XML instruction Magento will take care of to apply.

 
\vspace{0.5cm}
\begin{figure}[H]
  \centering
    \includegraphics[width=10cm]{images/xslt-processing.jpg}
  \caption{XSLT output processing}
  \label{fig:xslt-processing}
\end{figure}
\vspace{0.5cm}


\subsection{Practical examples}

As shown in figure \ref{fig:code-generation}, for our XSL Transformation we will use as source document the processed \textit{IFMLModel} in its XMI format.

The content of the XSLT responsible for generating a set of usable layout update instructions understandable by Magento has the form below:

\vspace{0.5cm}
\lstset{language=XML}
\begin{lstlisting} 
  <?xml version="1.0" encoding="UTF-8"?>
  <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                  version="1.0">
      <xsl:template match="/">
          <layout>
              <xsl:text>&#xa;</xsl:text>
              <xsl:comment>Append Header_RewardActions block to the Header</xsl:comment>
              <default>
                  <xsl:if test="//interactionFlowModelElements[@name='Header']/viewElements[@name='RecentRewardActions']">
                      <refrerence name="header">
                          <block type="MagentoEnhanced/Header_RewardActions"
                                 template="enhanced/header/reward-actions.phtml">
                              <label>Magento Enhanced Header Reward Actions</label>
                          </block>
                      </refrerence>
                  </xsl:if>
              </default>
              <xsl:text>&#xa;</xsl:text>
              <cms_index_index>
                  <xsl:text>&#xa;</xsl:text>
                  <xsl:text>&#xa;</xsl:text>
                  <xsl:comment>Set proper data for main banner carousel</xsl:comment>
                  <reference name="highlighted-categories-carousel">
                      <xsl:for-each
                              select="//interactionFlowModelElements[@name='Homepage']/viewElements[@name='HighlightedCategoriesCarousel']//parameters/constraints">
                          <block
                                  type="MagentoEnhanced/Homepage_CategoryHighlighted"
                                  template="enhanced/homepage/category/highlighted.phtml">
                              <xsl:attribute name="categoryId">
                                  <xsl:value-of select="substring-after(@body,'Category.ID=')"/>
                              </xsl:attribute>
                              <label>Magento Enhanced Highlighted Cateogry #<xsl:value-of
                                      select="position()"></xsl:value-of>
                              </label>
                          </block>
                      </xsl:for-each>
                  </reference>
                  <xsl:text>&#xa;</xsl:text>
                  <xsl:text>&#xa;</xsl:text>
                  <xsl:comment>Replace recent products with interaction products</xsl:comment>
                  <xsl:if test="//interactionFlowModelElements[@name='Homepage']/viewElements[@name='RecentlyInteractedProducts']">
                      <remove name="homepage.new-products"></remove>
                      <reference name="content">
                          <block name="homepage.interacted-products" type="MagentoEnhanced/Catalog_ProducstInteracted"
                                 template="enhanced/catalog/products-interacted.phtml">
                              <label>Magento Enhanced Interacted Products</label>
                              <action method="setData">
                                  <skuList>
                                      <xsl:variable name="body"
                                                    select="//interactionFlowModelElements[@name='Homepage']/viewElements[@name='RecentlyInteractedProducts']/viewComponentParts/subViewComponentParts/@body"/>
                                      <xsl:value-of
                                              select="substring-before(substring-after($body,'Product.sku IN ('),')')"/>
                                  </skuList>
                              </action>
                          </block>
                      </reference>
                  </xsl:if>
              </cms_index_index>
              <xsl:text>&#xa;</xsl:text>
              <xsl:comment>Add Related Product customization to Product Page</xsl:comment>
              <catalog_product_index>
                  <reference name="product.related-product-list">
                      <xsl:if test="//interactionFlowModelElements[@name='Product']/viewElements[@name='RelatedProductList']/viewComponentParts[@name='Product']/subViewComponentParts[@xsi:type='core:ConditionalExpression']">
                          <action method="setData">
                              <isCustom>true</isCustom>
                          </action>
                      </xsl:if>
                  </reference>
              </catalog_product_index>
              <xsl:text>&#xa;</xsl:text>
              <xsl:comment>Add Recently Viewed widget to Category page</xsl:comment>
              <catalog_category_view>
                  <xsl:if test="//interactionFlowModelElements[@name='Category']/viewElements[@name='RecentlyViewedProducts']">
                      <reference name="content">
                          <block before="category.main-content" name="homepage.recently-viwed-products"
                                 type="MagentoEnhanced/Catalog_ProductsViewed"
                                 template="enhanced/catalog/products-viewed.phtml">
                              <label>Magento Enhanced Recently Viewed Products</label>
                              <action method="setData">
                                  <idList>
                                      <xsl:variable name="body"
                                                    select="//interactionFlowModelElements[@name='Category']/viewElements[@name='RecentlyViewedProducts']/viewComponentParts/subViewComponentParts/@body"/>
                                      <xsl:value-of
                                              select="substring-before(substring-after($body,'Product.ID IN ('),')')"/>
                                  </idList>
                              </action>
                          </block>
                      </reference>
                  </xsl:if>
              </catalog_category_view>
              <xsl:text>&#xa;</xsl:text>
              <xsl:comment>Update the Shopping Cart appending the Apply Reward section</xsl:comment>
              <checkout_cart_index>
                  <xsl:if test="//viewElements[@name='Shopping Cart Sidebar']/viewElements[@name='Applicable Reward Points']">
                      <reference name="cart.shopping-cart-sidebar">
                          <block type="MagentoEnhanced/Checkout_RewardPoints"
                                 template="enhanced/checkout/reward-points.phtml">
                              <label>Magento Enhanced Checkout Reward Points</label>
                              <xsl:for-each
                                      select="//viewElements[@name='Shopping Cart Sidebar']/viewElements[@name='Applicable Reward Points']/viewComponentParts[@xsi:type='core:VisualizationAttribute']">
                                  <action method="addItemRender">
                                      <type>simple</type>
                                      <name>
                                          <xsl:value-of select="@name"/>
                                      </name>
                                  </action>
                              </xsl:for-each>
                          </block>
                      </reference>
                  </xsl:if>
              </checkout_cart_index>
          </layout>
      </xsl:template>
  </xsl:stylesheet>
  
  
\end{lstlisting}
\vspace{0.5cm}

%\addcontentsline{toc}{chapter}{}
